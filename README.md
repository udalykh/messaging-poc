# messaging-poc

### Общее описание

Данный проект содержит "proof-of-concept" код для интеграции с внешними сервисами (например Colvir) на основе асинхронных механизмов, основанных на
обмене сообщениями между вызывающим кодом и внешним сервисом. Данный подход позволяет обеспечить меньший уровень зависимости между компонентами, 
тем самым улучшая безопасность и масштабируемость.
 
Проект использует [Spring integration](https://projects.spring.io/spring-integration/) как основу для работы с конкретными механизмами работы с
сообщениями и основная часть кода, имеющего отношение к работе с сообщениями, сводится к Spring конфигурации имеющихся компонентов,
предоставляемыми библиотекой *Spring integration*:

 * *Outbound Gateway* создает сообщение с заданным payload и посылает его в request очередь; затем ожидает ответного сообщения из reply очереди 
 (с неким предопределенным таймаутом);
 * *Inbound Gateway* ожидает сообщения из request очереди и, по получении, обрабатывает его, а затем посылает ответное сообщение в reply очередь
 
*Spring Integration* является ядром механизма интеграции основанного на посылке сообщений; для различных конкретных message brokers имеются 
 дополнительные библиотеки, расширяющие функциональность ядра:
 
 * *spring-integration-jms* для поддержки JMS-based message brokers (Apache ActiveMQ, IBM WebSphere MQ)  
 * *spring-integration-amqp* для поддержки AMQP-based message brokers (RabbitMQ)
 * *spring-integration-kafka* для поддержки Apache Kafka streaming platform (в текущией версии имплементация поддержки Kafka ограничена и требует 
 написания дополнительного кода в дополнение к Spring конфигурации)
 

### Структура проекта
 
 Проект состоит из 3 модулей:
 
 * *core* содержит интерфейс `BIProcessor` с набором методов, используемых для получения бизнес информации из какого-либо сервиса (например, 
 получение списка VIN кодов). Данный интерфейс не привязан как ни к какой конкретной имплементации, так и ни к какому конкретному механизму получения
 информации
 
 * *colvir-messaging-adapter* содержит Spring конфигурационные файли и классы, а также классы и интерфейсы расширяющие и имлементирующие `BIProcessor`:
 
    - `MessagingBiProcessor` интерфейс, расширяющий `BIProcessor` и добавляющий к методам интерфейса аннотации, специфичные для *Spring integration*, 
    который, в свою очередь, используя данные аннотации, внутренне создает класс, являющийся Spring bean, имлементирующий методы интерфейса на основе 
    выше-описанного *Outbound Gateway*. В результате, появляется возможность путем обычного для Spring механизма инжектирования бина с типом 
    `BIProcessor`, вызывать его методы, что будет приводить к посылке механизмом *Spring integration* сообщений в некую request очередь с параметрами 
    метода, служащими как payload для сообщения, и последующим ожиданием ответного сообщения с payload, который будет использоваться как возвращаемое 
    методом значение.
      
    - `ColvirBiProcessor` класс, имплементирующий `BIProcessor` и служащий для обращения непосредственно к внешнему сервису - в нашем случае это может
    быть Colvir. Этот класс использует *Spring integration* аннотации и является частью *Inbound Gateway* - payload из полученных сообщений 
    используется как параметры для методов `ColvirBiProcessor`, а возвращаемые значения трактуются как payload для сообщений посылаемых обратно из 
    Gateway
    
    *colvir-messaging-adapter* модуль содержит набор Spring XML configuration файлов, часть из них является общими для всех потенциальных типов 
    message brokers (JMS, AMQP, Kafka); другая же часть является XML файлами, специфичными для конкретных типов message brokers. Для POC все эти 
    конфигурационные файлы используются при различных конфигурациях запуска приложения; в случае же production кода можно ограничиться лишь одним
    набором XML кинфигураций (например для JMS)
    
 * *colvir-messaging-app* пример приложения, использующего *colvir-messaging-adapter*. *colvir-messaging-app* содержит REST controller `Endpoint` в
 который инжектится `BIProcessor` интерфейс. Необходимо отметить, что вызывающий код не содержит никаких явных зависимостей от конкретной имплементации 
 - в данном случае, это имплементация, основанная на *Spring Integration* messaging.
    
    
### Конфигурации запуска приложения

 На данный момент код из бранча `master` может быть запущен as-is для message brokers Apache ActiveMQ, IBM MQ или RabbitMQ; для запуска кода 
 использующего Kafka необходимо использовать бранч с соответвующим именем (для Kafka имплементация требует изменений в Java коде, а не только в Spring 
 конфигурации по причине неполной имплементации Spring integration адаптера для Kafka).
              
 Приложение может быть запущено в одном из двух вариантов:
    
 * *Shared JVM* - в этом случае *Outbound Gateway* и *Inbound Gateway* запускаются внутри одной и той же Java Virtual Machine; этот режим запуска 
   является режимом по-умолчанию
   
 * *Separated JVMs* - в этом случае gateways запускаются каждый в своей Java Virtual Machine; этот вариант запуска соответствует использованию 
   компонента как частей архитектуры, основанной на отдельных micro-services:
    - для запуска приложения в режиме *message producer* и активации только *Outbound Gateway* необходимо передать JVM следующее конфигурационное свойство:
         `-Dspring.profiles.active=bi-producer`
    - для запуска приложения в режиме *message consumer* и активации только *Inbound Gateway* необходимо передать JVM следующее конфигурационное свойство:
         `-Dspring.profiles.active=bi-consumer`
         
 По умолчанию, приложение запускается со встроенным message broker использующим *Apache ActiveMQ* внутри той же самой JVM. Для работы с внешним Apache 
 ActiveMQ-based message broker приложению необходимо передать URL брокера как JVM свойство `brokerURL`:
      
    -DbrokerURL=tcp://localhost:61616
             
 Для запуска приложения в режиме использования RabbitMQ message broker приложению необходимо передать JVM свойство:
     
    -Dspring.profiles.active=rabbitmq
       
 Для запуска приложения в режиме использования IBM MQ message broker приложению необходимо передать JVM свойство:
     
    -Dspring.profiles.active=ibmmq
 (для IBM MQ будет необходимо передать еще одно IBM MQ specific свойство `ibmmq.wmqChannel` равное "QM_TEST.MY" по умолчанию)
       
 Если необходимо запустить приложение как *message producer* для RabbitMQ со специфичным broker URL, то набор JVM свойств может выглядеть как
          
    -Dspring.profiles.active=rabbitmq,bi-producer -DbrokerURL=tcp://localhost:61616     
    
 Настройки приложения по умолчанию хранятся в файле `application.yml`; любое из значений свойств в данном файле может быть заменено другим при запуске
 приложения путем указания конфигурационного свойства JVM с тем же именем:
  
    -Dbi.messaging.requestDestination=custom-destination  
  

  

    

